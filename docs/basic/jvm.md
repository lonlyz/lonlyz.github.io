---
sidebar: auto
editLink: false
---

# JVM内存管理

> [[博客园左潇龙的技术博客](http://www.cnblogs.com/zuoxiaolong)]
>
> [工程师搁浅](https://www.cnblogs.com/aishangJava/p/9541920.html)

## JVM内存管理概述

### 内存划分

虚拟机将内存分为六大部分。

- pc寄存器

  线程独有。全称是程序计数寄存器，记载每一个线程运行的java方法的地址，如果执行的是本地方法，程序计数器会是一个空地址。作用是支持多线程，记住每个线程执行的位置，也就是每个线程都会有一个程序计数器。

- java虚拟机栈

  线程独有。在创建线程的时候创建，用于存储栈帧。

  1. 栈帧，方法运行时，临时的数据存储区域。包含数据和部分的过程结果，与此同时它又肩负处理方法返回值、动态链接和异常分派的任务。随着方法的创建而创建，方法的结束而销毁；如果方法抛出异常，也会进行销毁。
  2. 局部变量表，方法局部变量的列表，相当于一个对象数组。
  3. 操作数栈，后进先出(LIFO)的栈，长度在编译器就写入class文件中，是固定长度。提供字节码指令操作变量计算的空间。

- java堆

  全局共享，随着虚拟机的启动创建，储存所有的对象实例和数组对象，内置了“自动内存管理系统”，也就是垃圾收集器(GC)。

- 方法区

  全局共享，主要储存运行时常量池，字段信息，方法信息，构造方法和普通函数的字节码内容以及一些特殊的方法。与java堆的区别除了存储的东西不同，最大的区别是不强制要求实现GC。

- 运行时常量池

- 本地方法栈

  线程独有，支持native方法的执行。

## GC简介

前提：为了避免内存溢出和内存泄漏。

解决的问题：

- 哪些对象可以被回收
- 什么时候回收对象
- 采用什么方式进行回收

## GC算法

- 引用计数算法

  效率最高，对于循环引用的对象无法进行回收。

- 根搜索算法

  弥补引用计数算法的缺陷，设立若干根节点，当任何一个根对象到某一个对象均不可达，则认为该对象是可以被回收的。

  GC roots的对象有以下几种：

  1. 虚拟机栈中引用的对象。（本地变量表）
  2. 方法区中类静态属性引用的对象。（static定义的属性）
  3. 方法区中的常量引用的对象。 （final定义的属性）
  4. 本地方法栈中JNI的引用对象。（本地变量表）

- 垃圾收集算法

  根搜素算法，主要解决的是哪些对象可以被回收，但是什么时候回收，以及采用什么方式进行回收。因此对**根搜索方法**进行扩充，**标记-清除算法**，**复制算法**，**标记-整理算法**。

  1. 标记-清除算法

     当堆中的有效内存被耗尽的时候，就会停止整个应用程序，然后遍历所有的根对象，将可达的对象**标记**为存活对象，将没有标记的对象进行**清除**。

     问题一：为什么需要停止应用程序

     回答：如果在进行GC的时候，刚好new 一个新的对象，标记为不可达进行清除，那么当GC完成后，刚创建的对象就为null。

     标记-清除算法的缺点：

     - 效率比较低，递归与全堆遍历，而且在GC的时候，会停止应用程序。这会导致用户体验非常差劲。
      - 这种方式清除的内存是不连续的，会造成内存的布局十分混乱，会为维持内存布局进行其它的开销。

  2. 复制算法

     将内存划分为两个区间，在任意时间点，所有动态分配的对象都只能分配在其中一个区间(活区间)，另一个区间(空闲区间)则是空闲的。

     当有效内存耗尽时，jvm将暂停程序进行，开启复制算法GC。接下来GC线程会将活动区间的存活线程全部复制到空闲区间(此时，需要被回收的对象已经被回收掉)，且严格按照内存地址依次排列。此时，GC线程将更新存活对象的内存引用地址指向新的内存地址。

     复制算法的缺点：

     - 浪费了一半的内存。
     - 如果对象的存活率很高，需要将所有的对象复制一遍，并将引用地址重置一遍。复制的动作需要花费时间，在存活对象比较多的时候，将会变得不可忽视。

       复制算法想要使用，内存对象的存活率要非常低才可以，还要客服一半内存的浪费。

  3. 标记-整理算法

     与标记-清除算法类似，都是先遍历GC roots, 将存活的对象进行标记，移动所有的存活对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此第二阶段称为整理阶段。

     弥补了标记-清除算法的内存区域分散的缺点和复制算法的消耗一半内存的缺点。

     标记-整理算法的缺点：

     - 效率不高，标记所有的存活对象，还要整理所有的存活对象的引用地址。效率低于复制算法。

     总结：

     1. 三个算法都依赖根搜索算法判断一个对象是否应该被回收，而支持根搜索算法可以正常工作的理论依据，就是语法中变量作用域的相关内容。防止内存泄漏，就要掌握好变量作用域。

     2. 在GC线程开启时，都要停止应用程序。

        效率：复制算法>标记-整理算法>标记-清除算法

        内存整齐度：复制算法=标记-整理算法>标记-清除算法

        内存利用率：标记-整理算法=标记-清除算法>复制算法

  4. 分代收集算法--最优解

     分代收集算法其实是对以上三个垃圾回收算法的实际应用。

     分代收集算法针对java堆设计的。

     回收时机：

     ​		jvm再进行GC的时候，不是对上述三个区域都进行回收。

     - 普通GC（minor gc）: 针对新生代区域的GC。
     - 全局GC （minor gc or full gc）: 针对老年代的GC, 偶尔伴随对新生代的GC以及对永久代的GC。

## 垃圾收集器

[see current](https://www.cnblogs.com/zuoxiaolong/p/jvm6.html)

